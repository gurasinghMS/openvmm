// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

//! A command match builder

use nvme_resources::fault::CommandMatch;
use nvme_spec::Command;
use zerocopy::FromZeros;
use zerocopy::IntoBytes;

/// A command matcher that can be used to generate and match command match patterns for nvme commands
pub struct CommandMatchBuilder {
    command: Command,
    mask: Command,
}

impl CommandMatchBuilder {
    /// Generates a matcher for every command
    pub fn new() -> Self {
        CommandMatchBuilder {
            command: Command::new_zeroed(),
            mask: Command::new_zeroed(),
        }
    }

    /// Configure the matcher to a specific opcode. Multiple calls overwrite functionality.
    /// If you need to match against multiple patterns, consider using multiple CommandMatcher instances.
    pub fn with_cdw0_opcode(&mut self, opcode: u8) -> &mut Self {
        self.command.cdw0 = self.command.cdw0.with_opcode(opcode);
        self.mask.cdw0 = self.mask.cdw0.with_opcode(u8::MAX);
        self
    }

    /// Configure the matcher to a specific cdw0 pattern. Multiple calls overwrite functionality.
    /// Mask bits == 1 are required to be an exact match and == 0 are treated as a wildcard.
    pub fn with_cdw0(&mut self, cdw0: u32, mask: u32) -> &mut Self {
        self.command.cdw0 = cdw0.into();
        self.mask.cdw0 = mask.into();
        self
    }

    /// Configure the matcher to a specific cdw10 pattern. Multiple calls overwrite functionality.
    /// Mask bits == 1 are required to be an exact match and == 0 are treated as a wildcard.
    pub fn with_cdw10(&mut self, cdw10: u32, mask: u32) -> &mut Self {
        self.command.cdw10 = cdw10;
        self.mask.cdw10 = mask;
        self
    }

    /// Returns a CommandMatch object that corresponds/matches to the configured command values and masks
    pub fn build(&self) -> CommandMatch {
        CommandMatch {
            command: self.command,
            mask: self
                .mask
                .as_bytes()
                .try_into()
                .expect("mask should be 64 bytes"),
        }
    }

    /// Given a CommandMatching mask generated by this struct and a command return whether the given command matches the pattern
    pub fn compare(range: &CommandMatch, command: &Command) -> bool {
        let command_lhs = range.command.as_bytes();
        let command_rhs = command.as_bytes();
        let mask_bytes = &range.mask;

        !command_lhs
            .iter()
            .zip(command_rhs.iter())
            .zip(mask_bytes.iter())
            .any(|((lhs, rhs), mask)| ((lhs ^ rhs) & mask) != 0)
    }
}
